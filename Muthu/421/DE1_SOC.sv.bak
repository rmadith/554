
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
`default_nettype none
module DE1_SOC(

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_DIN,
	input 		          		ADC_DOUT,
	output		          		ADC_SCLK,

	//////////// Audio //////////
	input 		          		AUD_ADCDAT,
	inout 		          		AUD_ADCLRCK,
	inout 		          		AUD_BCLK,
	output		          		AUD_DACDAT,
	inout 		          		AUD_DACLRCK,
	output		          		AUD_XCK,

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// I2C for Audio and Video-In //////////
	output		          		FPGA_I2C_SCLK,
	inout 		          		FPGA_I2C_SDAT,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
	inout 		    [35:0]		GPIO
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
wire rst_n, clk, pll_locked, debug_sig;
wire [31:0] boot_addr, boot_data;
wire cpu_rst_n;

reg write;
reg [5:0] done;
wire [11:0] joystick_data;

wire [31:0] memMappedAddr, memMappedDataOut;

// Debug State Machine
typedef enum reg {IDLE, DEBUG} debug_state_t;
debug_state_t state, nxt_state;

always_ff @(posedge clk, negedge rst_n)
	if(!rst_n)
		state <= IDLE;
	else
		state <= nxt_state;
		
always_comb begin
	nxt_state = state;
	case(state)
		default: if(!debug_sig) nxt_state <= DEBUG;
		DEBUG: if(!debug_sig) nxt_state <= IDLE;
	endcase
end


//=======================================================
//  Structural coding
//=======================================================
assign LEDR[8] = !rst_n;
assign LEDR[7] = state;

// Debouncing
// reset_synch irst(.RST_n(KEY[0]), .clk(clk), .rst_n(rst_n), .pll_locked(pll_locked));
// reset_synch idebug(.RST_n(KEY[1]), .clk(clk), .rst_n(debug_sig), .pll_locked(1'b1));
assign rst_n = KEY[0];
assign debug_sig = KEY[1];

// PLL
// pll iPLL (.refclk(CLOCK2_50), .rst(~KEY[0]),.outclk_0(clk),.outclk_1(VGA_CLK),
//            .locked(pll_locked));
assign clk = CLOCK2_50;

// Bootloader
bootloader iboot (.clk(clk), .rst_n(rst_n), .debug(state), .addr(boot_addr), .data(boot_data), 
					.increment(LEDR[6]), .RX(GPIO[5]), .TX(GPIO[3]), .outdata(memMappedDataOut), .write(write));

					
assign cpu_rst_n = (state) ? 1'b0 : rst_n;
// CPU
cpu iCPU(.clk(clk), .rst_n(rst_n | state), .boot_addr(boot_addr), .boot_data(boot_data), 
			.debug(state), .memMappedAddr(memMappedAddr), .memMappedDataOut(memMappedDataOut), .joystick_data({20'b0,joystick_data}), .halt(LEDR[9]));

// Memory Mapping
always_comb begin
	write = 0;
	done = 'b0;
	// we_cpu = 0;
	case(memMappedAddr)
		32'hFFFFC001: 	write = 1;								// TX from bootloader to Macbook
		32'hFFFFC002: 	done = memMappedDataOut[5:0];			// Write to joystick
		// BMP_CTL: 		we_cpu = 1;
		// BMP_YLOC: 		we_cpu = 1;
		// BMP_XLOC: 		we_cpu = 1;
		default: 		write = 0;
	endcase
end

// Joystick
joystick ijoy (.ADC_CONVST(ADC_CONVST), .ADC_DIN(ADC_DIN), .ADC_DOUT(ADC_DOUT), 
					.ADC_SCLK(ADC_SCLK), .clk(clk), .rst_n(rst_n), .done(done), .val(joystick_data));

// Debug : SEG7 display
SEG7_LUT_6 	iseg (.oSEG0(HEX0),.oSEG1(HEX1), .oSEG2(HEX2),.oSEG3(HEX3), .oSEG4(HEX4),.oSEG5(HEX5), .iDIG(boot_addr[23:0]));



endmodule
