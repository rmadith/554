
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
`default_nettype none

module CPU1(

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_DIN,
	input 		          		ADC_DOUT,
	output		          		ADC_SCLK,

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
	inout 		    [35:0]		GPIO,

	///////// HEX0 /////////
	output      [6:0]  HEX0,

	///////// HEX1 /////////
	output      [6:0]  HEX1,

	///////// HEX2 /////////
	output      [6:0]  HEX2,

	///////// HEX3 /////////
	output      [6:0]  HEX3,

	///////// HEX4 /////////
	output      [6:0]  HEX4,

	///////// HEX5 /////////
	output      [6:0]  HEX5
);


localparam BMP_CTL =  32'hFFFFC008;          // address for BMP Control
localparam BMP_XLOC = 32'hFFFFC009;         // address for BMP X Location
localparam BMP_YLOC = 32'hFFFFC00A;         // address for BMP Y Location
localparam BMP_STAT = 32'hFFFFC00B;         // address for BMP Status 


//=======================================================
//  REG/WIRE declarations
//=======================================================

// Debounced
wire debug_sig, rst_n;

// PLL
wire clk, pll_locked;

// Bootloader
wire [31:0] data_cpu, waddr_cpu;

// Data from cpu
wire [31:0] waddr_out, data_out;

// Joystick
wire [11:0] joystick_data;
reg [5:0] done;

// VGA
reg [9:0] xloc, yloc;  
wire add_fnt;
wire [5:0] fnt_indx;
wire add_img;
wire [4:0] image_indx;
wire rem_img;
wire busy;

// Memory mapped sm outputs
reg write, we_cpu;

// I know this can be simpler but my brain is not working at 04/16/2023
// Holding the debug state
typedef enum reg {IDLE, DEBUG} state_t;
state_t state, nxt_state;

always_ff @(posedge clk, negedge rst_n)
	if(!rst_n)
		state <= IDLE;
	else
		state <= nxt_state;
		
always_comb begin
	nxt_state = state;
	case(state)
		default: if(!debug_sig) nxt_state <= DEBUG;
		DEBUG: if(!debug_sig) nxt_state <= IDLE;
	endcase
end
////////////////////////////////////////////////////////////////////





//=======================================================
//  Structural coding
//=======================================================

// Debug outputs
assign LEDR[8] = !rst_n;
assign LEDR[7] = state;

// Debouncing Keys
reset_synch irst(.RST_n(KEY[0]), .clk(clk), .rst_n(rst_n), .pll_locked(pll_locked));
reset_synch idebug(.RST_n(KEY[1]), .clk(clk), .rst_n(debug_sig), .pll_locked(1'b1));

// PLL
PLL iPLL (.refclk(CLOCK2_50), .rst(~KEY[0]),.outclk_0(clk),.outclk_1(VGA_CLK),
           .locked(pll_locked));

// Bootloader
bootloader iboot (.clk(clk), .rst_n(rst_n), .debug(state), .addr(waddr_cpu), .data(data_cpu), .increment(LEDR[6]), .RX(GPIO[5]), .TX(GPIO[3]), .outdata(data_out), .write(write));


// CPU
cpu iCPU (.clk(clk), .rst_n(rst_n | state), .debug(state), .data_cpu(data_cpu), .waddr_cpu(waddr_cpu), .waddr_out(waddr_out), .data_out(data_out), .halt(LEDR[9]), .joystick_data({busy, 19'b0, joystick_data}));

// Joystick
joystick ijoy (.ADC_CONVST(ADC_CONVST), .ADC_DIN(ADC_DIN), .ADC_DOUT(ADC_DOUT), .ADC_SCLK(ADC_SCLK), .clk(clk), .rst_n(rst_n), .done(done), .val(joystick_data));


// BitMap Display
// BMP_display IBMP (.clk(clk), .VGA_CLK(VGA_CLK), .rst_n(rst_n), .VGA_BLANK_N(VGA_BLANK_N), .VGA_B(VGA_B), .VGA_G(VGA_G), .VGA_HS(VGA_HS), .VGA_R(VGA_R), 
// 					.VGA_SYNC_N(VGA_SYNC_N), .VGA_VS(VGA_VS), .xloc(xloc), .yloc(yloc), .add_fnt(add_fnt), .fnt_indx(fnt_indx), .add_img(add_img), 
// 					.image_indx(image_indx), .rem_img(rem_img), .busy(busy));

SEG7_LUT_6 	iseg (.oSEG0(HEX0),.oSEG1(HEX1), .oSEG2(HEX2),.oSEG3(HEX3), .oSEG4(HEX4),.oSEG5(HEX5), .iDIG(waddr_cpu[23:0]));


always_comb begin
	write = 0;
	done = 'b0;
	we_cpu = 0;
	case(waddr_out)
		32'hFFFC001: 	write = 1;
		32'hFFFC002: 	done = data_out[5:0];
		BMP_CTL: 		we_cpu = 1;
		BMP_YLOC: 		we_cpu = 1;
		BMP_XLOC: 		we_cpu = 1;
		default: 		write = 0;
	endcase
end

//   // Updating Xloc
always @(posedge clk, negedge rst_n)
    if(!rst_n)
      xloc = 'b0;
    else if(waddr_out == BMP_XLOC && we_cpu) // Qualifying the write
      xloc = data_out[9:0];

//   // Update Yloc
always @(posedge clk, negedge rst_n)
    if(!rst_n)
      yloc = 'b0;
    else if(waddr_out == BMP_YLOC && we_cpu) // Qualifying the read
      yloc = data_out[9:0];

assign add_fnt = (waddr_out === BMP_CTL && we_cpu) ? data_out[15] : 1'b0;
assign fnt_indx = (waddr_out === BMP_CTL && we_cpu) ? data_out[14:9] : 'b0;
assign add_img = (waddr_out === BMP_CTL && we_cpu) ? data_out[6] : 'b0;
assign image_indx = (waddr_out === BMP_CTL  && we_cpu) ? data_out[4:0] : 5'h01;
assign rem_img = (waddr_out === BMP_CTL && we_cpu) ? data_out[5] : 1'b0;


endmodule
