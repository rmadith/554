
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
`default_nettype none
module joystick(

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_DIN,
	input 		          		ADC_DOUT,
	output		          		ADC_SCLK,

	//////////// CLOCK //////////
	input 		          		clk, rst_n,

	input [5:0] done,

	output [11:0] joystick_data 
);

typedef enum reg[2:0] {X1, Y1, PS1, X2, Y2, PS2} state_t;
typedef enum reg {FIRST, AFTER} Y2_state_t;

//=======================================================
//  REG/WIRE declarations
//=======================================================
wire update;
wire x1_done, x2_done, y1_done, y2_done, ps1_done, ps2_done;
wire [11:0] volume;
wire [15:0] cmd;

reg addr_rst;
reg X1_update, Y1_update, PS1_update, X2_update, Y2_update, PS2_update;
reg [1:0] x1_val, y1_val, ps1_val, x2_val, y2_val, ps2_val/* synthesis keep */;
reg [2:0] addr;

state_t state, nxt_state;
Y2_state_t curr, nxt;

// Acknowledge signal. Initially designed to individually reset joystick values
assign {x1_done, x2_done, y1_done, y2_done, ps1_done, ps2_done} = done;

// Concatenated data from joystick
assign joystick_data = {x1_val, y1_val, ps1_val, x2_val, y2_val, ps2_val};

//=======================================================
//  Structural coding
//=======================================================

A2D_intf iADC(.clk(clk),.rst_n(rst_n),.val0(volume),.CONVST(ADC_CONVST),
                .SCLK(ADC_SCLK),.MOSI(ADC_DIN),.MISO(ADC_DOUT), .cmd(cmd), .update(update));
					 

// Using Cheese logic to keep track of commands and signals
always_ff @(posedge clk, negedge rst_n)
	if(!rst_n)
		addr <= 3'b0;
	else if(addr_rst)
		addr <= 3'b0;
	else if(update)
		addr <= addr + 1;

// State Machine to remove first garbage value
// I know I could have double flopped the Y2_Update signal :(
always_ff @(posedge clk, negedge rst_n)
	if(!rst_n)
		curr <= FIRST;
	else
		curr <= nxt;
		
// First SPI Transaction is garbage :)
always_comb begin
	nxt = curr;
	case(curr)
		FIRST: if (Y2_update) nxt = AFTER;
		default: nxt = AFTER;
	endcase
end
		


// ROM with commands used to communicate with ADC
always_comb begin
	case(addr)
		3'b000: cmd = 16'hA800;
		3'b001: cmd = 16'hD800;
		3'b010: cmd = 16'hE800;
		3'b011: cmd = 16'hC800;
		3'b100: cmd = 16'h8800;
		3'b101: cmd = 16'h9800;
		default: cmd = 16'b0;
	endcase
end

// State Machine that changes what registers to be updated and which command to be sent
always_ff @(posedge clk, negedge rst_n) begin
    if(!rst_n)
		state <= X1;
	else
		state <= nxt_state;
end


always_comb begin
    nxt_state = state;
	X1_update = 'b0;
	Y1_update = 'b0;
	PS1_update = 'b0;
    X2_update = 'b0;
	Y2_update = 'b0;
	PS2_update = 'b0;
	addr_rst = 0;
	case(state)
		default: if(update) begin
					Y2_update = 1;
					nxt_state = Y1;
				 end
		Y1: 	if(update) begin
					PS2_update = 1;
					nxt_state = PS1;
				 end
		PS1: 	if(update) begin
					X1_update = 1;
					nxt_state = X2;
				 end
		X2: 	if(update) begin
					Y1_update = 1;
					nxt_state = Y2;
				 end
		Y2: 	if(update) begin
					PS1_update = 1;
					nxt_state = PS2;
				 end
		PS2: 	if(update) begin
					X2_update = 1;
					nxt_state = X1;
					addr_rst = 1;
				 end
	endcase
end



// Joystick Value holding registers. All registers are 2 bits to ensure alignment
always_ff @(posedge clk, negedge rst_n)
	if(!rst_n)
		x1_val <= 'b0;
	else if(x1_done)
		x1_val <= 2'b00;
	else if(X1_update && (volume > 12'hDFF))
		x1_val <= 2'b10;
	else if(X1_update && (volume < 12'h05F))
		x1_val <= 2'b01;


always_ff @(posedge clk, negedge rst_n)
	if(!rst_n)
		y1_val <= 'b0;
	else if(y1_done)
		y1_val <= 2'b00;
	else if(Y1_update && (volume > 12'hDFF))
		y1_val <= 2'b10;
	else if(Y1_update && (volume < 12'h05F))
		y1_val <= 2'b01;
	

always_ff @(posedge clk, negedge rst_n)
	if(!rst_n)
		ps1_val <= 'b0;
	else if(ps1_done)
		ps1_val <= 2'b00;
	else if(PS1_update && volume < 12'h05F)
		ps1_val <= 2'b10;
	

always_ff @(posedge clk, negedge rst_n)
	if(!rst_n)
		x2_val <= 'b0;
	else if(x2_done)
		x2_val <= 2'b00;
	else if(X2_update && (volume > 12'hDFF))
		x2_val <= 2'b10;
	else if(X2_update && (volume < 12'h05F))
		x2_val <= 2'b01;
	


always_ff @(posedge clk, negedge rst_n)
	if(!rst_n)
		y2_val <= 'b0;
	else if(y2_done)
		y2_val <= 2'b00;
	else if(Y2_update && (volume > 12'hDFF) && curr)
		y2_val <= 2'b10;
	else if(Y2_update && (volume < 12'h05F) && curr)
		y2_val <= 2'b01;

always_ff @(posedge clk, negedge rst_n)
	if(!rst_n)
		ps2_val <= 'b0;
	else if(ps2_done)
		ps2_val <= 2'b00;
	else if(PS2_update && volume < 12'h05F)
		ps2_val <= 2'b10;
	

		

endmodule


