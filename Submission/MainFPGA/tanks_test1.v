
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module tanks_test1(

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_DIN,
	input 		          		ADC_DOUT,
	output		          		ADC_SCLK,

	//////////// Audio //////////
	input 		          		AUD_ADCDAT,
	inout 		          		AUD_ADCLRCK,
	inout 		          		AUD_BCLK,
	output		          		AUD_DACDAT,
	inout 		          		AUD_DACLRCK,
	output		          		AUD_XCK,

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// I2C for Audio and Video-In //////////
	output		          		FPGA_I2C_SCLK,
	inout 		          		FPGA_I2C_SDAT,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	inout 		    [35:0]		GPIO_0,

	//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
	inout 		    [35:0]		GPIO_1
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

reg remove;
reg joystick_out;
reg write, VGA_WRITE;
reg [5:0] done;
reg [31:0] data_out;

wire rdy;
wire pll_locked;
wire q_empty, busy;
wire rst_n, clk, debug_sig, cpu_rst_n, q_full, baud_sig;
wire [9:0] joystick_2;
wire [9:0] joystick_2_in;
wire [11:0] joystick_data;
wire [12:0] baud;
wire [31:0] memMappedDataOut, memMappedAddr;
wire [31:0] boot_addr, boot_data;

//=======================================================
//  Structural coding
//=======================================================

// Debug Signals
// HALT or the ECALL instruction is notified using LEDR[9]
assign LEDR[8] = !rst_n;
assign LEDR[7] = debug_sig;
assign LEDR[5] = !cpu_rst_n;
assign LEDR[3] = !SW[3];

// Segment was used to check if the number of addr booted is equal to number of addr in program
SEG7_LUT_6 	iseg (.oSEG0(HEX0),.oSEG1(HEX1), .oSEG2(HEX2),.oSEG3(HEX3), .oSEG4(HEX4),.oSEG5(HEX5), .iDIG(boot_addr[23:0]));

// Debouncing Keys and Switches
reset_synch irst(.RST_n(KEY[0]), .clk(clk), .rst_n(rst_n), .pll_locked(pll_locked));
reset_synch idebug(.RST_n(SW[0]), .clk(clk), .rst_n(debug_sig), .pll_locked(1'b1));


// PLL takes in 50 MHz clock and returns two clocks with 50MHz and 25MHz
pll iPLL (.refclk(CLOCK2_50), .rst(~KEY[0]),.outclk_0(clk),.outclk_1(VGA_CLK),
           .locked(pll_locked));

// Changes Baud during runtime so we can bootload from slower devices
assign baud = (SW[9]) ? 'h1458 : 'h01b2;

// Bootloader
bootloader iboot (.clk(clk), .rst_n(rst_n), .debug(debug_sig), .addr(boot_addr), .data(boot_data), 
					.increment(LEDR[6]), .RX(GPIO_1[5]), .TX(GPIO_1[3]), .outdata(memMappedDataOut), .write(write), .baud(baud));


// We are setting the CPU to reset stage when debugging to avoid any major data hazards due to code updates
assign cpu_rst_n = (debug_sig) ? 1'b0 : rst_n;

// CPU
// Since our datapath into the CPU (from externally memory devices) was 32 bits and we don't have concatenated data
// that exceeds 32 bits, we have concatenated the data and passed it into the CPU as the joystick_data input. 
// the structure of the joystick data goes as {VGA_BUSY, 8'b0, ready signal from joystick data 2, joystick data 2 (without ps1), joystick data 1}
cpu iCPU(.clk(clk), .rst_n(cpu_rst_n), .boot_addr(boot_addr), .boot_data(boot_data), 
			.debug(debug_sig), .memMappedAddr(memMappedAddr), .memMappedDataOut(memMappedDataOut), 
			.joystick_data({busy,8'b0, rdy,joystick_2,joystick_data}), .halt(LEDR[9]), .turn_off_DBP(SW[3]));


// Combinational block to memory map data coming from the CPU to externally memory mapped devices
// 32'hFFFFC001 is to send debug messages
// 32'hFFFFC002 is to acknowledge data from Joystick 1
// 32'hFFFFC003 is to write to VGA
// 32'hFFFFC004 is to acknowledge data from Joystick 2
always @(*) begin
	write = 0;
	done = 'b0;
	joystick_out = 1'b0;
	case(memMappedAddr)
		32'hFFFFC001 :  write = 1;
		32'hFFFFC002 :  done = memMappedDataOut[5:0];
		32'hFFFFC003 :  data_out = memMappedDataOut;
		32'hFFFFC004 :  joystick_out = 1'b1;
		default:		data_out = 'b0;
	endcase
end

// Joystick 1
joystick ijoy (.ADC_CONVST(ADC_CONVST), .ADC_DIN(ADC_DIN), .ADC_DOUT(ADC_DOUT), 
					.ADC_SCLK(ADC_SCLK), .clk(clk), .rst_n(rst_n), .done(done), .joystick_data(joystick_data));

// Joystick 2
// Unlike Joystick 1, we have a "rdy" signal due to its async nature. The data before rdy signal may not be valid. 
// The rdy signal is kicked back to 0 every time the CPU acknowledges.  
interface_to_secondary_FPGA iGame(.clk(clk), .rst_n(rst_n), .TX(GPIO_1[35]), .RX(GPIO_1[33]), .joystick_data(joystick_2), .ready(rdy), .send_done(joystick_out));


// Place BMP
// data from the cpu is split it in this way
// {xloc, yloc, 'b0, image_index, remove, add}
// 'b0 was added in hopes to add more ROMs to PlaceBMP
BMP_display IBMP (.clk(clk), .VGA_CLK(VGA_CLK), .rst_n(rst_n), .VGA_BLANK_N(VGA_BLANK_N), .VGA_B(VGA_B), .VGA_G(VGA_G), .VGA_HS(VGA_HS), .VGA_R(VGA_R), 
					.VGA_SYNC_N(VGA_SYNC_N), .VGA_VS(VGA_VS), .xloc(data_out[31:22]), .yloc(data_out[21:13]), .add_fnt(1'b0), .fnt_indx('b0), .add_img(data_out[0]), 
					.image_indx(data_out[7:2]), .rem_img(data_out[1]), .busy(busy));

endmodule
