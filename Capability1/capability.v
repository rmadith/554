
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module capability(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS
);

  localparam BMP_CTL = 16'hC008;          // address for BMP Control
  localparam BMP_XLOC = 16'hC009;         // address for BMP X Location
  localparam BMP_YLOC = 16'hC00A;         // address for BMP Y Location
  localparam BMP_STAT = 16'hC00B;         // address for BMP Status 
 
  wire clk, rst_n;
  reg [9:0] xloc, yloc;
  
  wire add_fnt;
  wire [5:0] fnt_indx;
  wire add_img;
  wire [4:0] image_indx;
  wire rem_img;
  wire busy;
  
  // Could be changed. we_cpu was an inherited change when we pulled the cpu out of the BMP_display
  wire we_cpu, re;
  wire [15:0] databus;
  wire [15:0] addr;  
  wire [15:0] inter_rdata;

  // Clock was pulled out because the PLL clock output and CLOCK_50 are not in exact phase(?). There was no display when the cpu and flipflops for 
  // xloc and yloc were posedge triggered by the ref clock

  // We pulled out clk and rst_n instead of pulling the module out because it would make BMP_display kind of useless. Originally we had BMP_display
  // as the top level and instantiated the cpu inside. Since we needed to change that, we pulled the cpu out. If we also pulled the PLL and the reset synch, the only
  // things left are Place_BMP, and videomem with VGA timing
  BMP_display iDUT(.CLOCK2_50(CLOCK2_50), .CLOCK3_50(CLOCK3_50), .CLOCK4_50(CLOCK4_50), .REF_CLK(CLOCK_50), .RST_n(KEY[0]), .LEDR(LEDR), 
    .VGA_BLANK_N(VGA_BLANK_N), .VGA_B(VGA_B), .VGA_CLK(VGA_CLK), .VGA_G(VGA_G), .VGA_HS(VGA_HS), .VGA_R(VGA_R), .VGA_SYNC_N(VGA_SYNC_N),
    .VGA_VS(VGA_VS), .xloc(xloc), .yloc(yloc), .add_fnt(add_fnt), .fnt_indx(fnt_indx), .add_img(add_img), .image_indx(image_indx), 
    .rem_img(rem_img), .busy(busy),.clk(clk),.rst_n(rst_n));

  // CPU instatiation 
  cpu iCPU(.clk(clk), .rst_n(rst_n), .rdata(inter_rdata), .wdata(databus), .re(re), .we(we_cpu), .addr(addr));

  // Updating Xloc
  always @(posedge clk, negedge rst_n)
    if(!rst_n)
      xloc = 'b0;
    else if(addr == BMP_XLOC && we_cpu) // Qualifying the write
      xloc = databus[9:0];

  // Update Yloc
  always @(posedge clk, negedge rst_n)
    if(!rst_n)
      yloc = 'b0;
    else if(addr == BMP_YLOC && we_cpu) // Qualifying the read
      yloc = databus[9:0];

  // Updating BMP_CTL. Doing it this way allows us to deassert when we move to the next instruction. 
  // Saving us on one instruction cycle
  assign add_fnt = (addr == BMP_CTL && we_cpu) ? databus[15] : 1'b0;
  assign fnt_indx = (addr == BMP_CTL && we_cpu) ? databus[14:9] : 'b0;
  assign add_img = (addr == BMP_CTL && we_cpu) ? databus[6] : 'b0;
  assign image_indx = (addr == BMP_CTL  && we_cpu) ? databus[4:0] : 5'h01;
  assign rem_img = (addr == BMP_CTL && we_cpu) ? databus[5] : 1'b0;

  // Mux for rdata so that it can be expanded in the future
  assign inter_rdata = (addr == BMP_STAT && re) ? {{15{1'h0}}, busy} : 1'b0;


endmodule
